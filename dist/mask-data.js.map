{"version":3,"sources":["../src/mask-data.js"],"names":["MaskData","constructor","maskOptions","options","_validateOptions","_mergeWithDefaultValues","defaultMaskOptions","maskWith","maxMaskedChars","unmaskedStartChars","unmaskedEndChars","maskString","maskNumber","maskBoolean","maskUndefined","maskNull","mergedOptions","Object","keys","forEach","name","undefined","reasons","normalizedOptions","parseInt","filter","option","isNaN","push","toString","length","MaskDataInvalidOptionException","_shouldBeMasked","sensitiveData","_doMask","data","String","maskLength","maskingCharacters","substr","maskedData","remainingChars","i","repeat","mask","whiteListFields","blackListFields","Array","isArray","map","item","key","includes"],"mappings":"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","sourcesContent":["/* eslint-disable no-restricted-globals */\n/* eslint-disable class-methods-use-this */\n/* eslint-disable no-unused-vars */\n\nimport MaskDataInvalidOptionException from './mask-data-invalid-option-exception';\n\n/**\n * Class for masking sensitive data\n */\nexport default class MaskData {\n    /**\n     * Class constructor\n     *\n     * @param {Object} [maskOptions={}] Mask options. Optional\n     */\n    constructor(maskOptions = {}) {\n        this.options = this._validateOptions(\n            this._mergeWithDefaultValues(maskOptions)\n        );\n    }\n\n    /**\n     * Getter for a mask default configuration.\n     *\n     * @returns {{maskNull: boolean, maskString: boolean, maxMaskedChars: number, maskWith: string, unmaskedEndChars: number, maskNumber: boolean, unmaskedStartChars: number, maskUndefined: boolean, maskBoolean: boolean}}\n     */\n    get defaultMaskOptions() {\n        return {\n            // A symbol for masking\n            maskWith: '*',\n            // Limits the output string length to 16\n            maxMaskedChars: 16,\n            // First N symbols that won't be masked\n            unmaskedStartChars: 0,\n            // Last N symbols that won't be masked\n            unmaskedEndChars: 0,\n            // Mask data with type 'string'\n            maskString: true,\n            // Mask data with type 'number'\n            maskNumber: true,\n            // Mask data with type 'boolean'\n            maskBoolean: true,\n            // Mask 'undefined' data\n            maskUndefined: true,\n            // Mask 'null' data\n            maskNull: true,\n        };\n    }\n\n    /**\n     * Merges provided configuration with a default one.\n     *\n     * @private\n     * @param {Object} [maskOptions={}] Mask options. Optional\n     * @returns {{maskNull: boolean, maskString: boolean, maxMaskedChars: number, maskWith: string, unmaskedEndChars: number, maskNumber: boolean, unmaskedStartChars: number, maskUndefined: boolean, maskBoolean: boolean}}\n     */\n    _mergeWithDefaultValues(maskOptions = {}) {\n        const mergedOptions = {\n            ...this.defaultMaskOptions,\n            ...typeof maskOptions === 'object' ? maskOptions : {},\n        };\n\n        Object.keys(this.defaultMaskOptions)\n            .forEach((name) => {\n                if (mergedOptions[name] === undefined || mergedOptions[name] === null) {\n                    mergedOptions[name] = this.defaultMaskOptions[name];\n                }\n            });\n\n        return mergedOptions;\n    }\n\n    /**\n     * Validates configuration options.\n     *\n     * @private\n     * @param {Object} [maskOptions={}] Mask options to validate\n     * @returns {{maskNull: boolean, maskString: boolean, maxMaskedChars: number, maskWith: string, unmaskedEndChars: number, maskNumber: boolean, unmaskedStartChars: number, maskUndefined: boolean, maskBoolean: boolean}}\n     * @throws MaskDataInvalidOptionException\n     */\n    _validateOptions(maskOptions = {}) {\n        const reasons = [];\n        const normalizedOptions = {\n            ...typeof maskOptions === 'object' ? maskOptions : {},\n            maxMaskedChars: parseInt(maskOptions.maxMaskedChars, 10),\n            unmaskedStartChars: parseInt(maskOptions.unmaskedStartChars, 10),\n            unmaskedEndChars: parseInt(maskOptions.unmaskedEndChars, 10),\n        };\n\n        // Options supports positive integers values only\n        ['maxMaskedChars', 'unmaskedStartChars', 'unmaskedEndChars']\n            .filter((option) => isNaN(normalizedOptions[option]) || normalizedOptions[option] < 0)\n            .forEach((option) => reasons.push(`'${option}' option value must be a positive integer.`));\n\n        // Options supports boolean values only\n        [\n            'maskString',\n            'maskNumber',\n            'maskBoolean',\n            'maskUndefined',\n            'maskNull',\n        ]\n            .filter((option) => normalizedOptions[option] !== true && normalizedOptions[option] !== false)\n            .forEach((option) => reasons.push(`'${option}' option value must be a boolean.`));\n\n\n        if (!normalizedOptions.maskWith || normalizedOptions.maskWith.toString().length <= 0) {\n            normalizedOptions.maskWith = this.defaultMaskOptions.maskWith;\n        }\n\n        if (reasons.length > 0) {\n            throw new MaskDataInvalidOptionException('Invalid mask configuration', reasons);\n        }\n\n        return normalizedOptions;\n    }\n\n    /**\n     * Checks if sensitive data should be masked.\n     *\n     * @private\n     * @param {*} sensitiveData\n     * @returns {boolean}\n     */\n    _shouldBeMasked(sensitiveData) {\n        if (sensitiveData === null) {\n            return this.options.maskNull;\n        }\n\n        if (sensitiveData === undefined) {\n            return this.options.maskUndefined;\n        }\n\n        if (sensitiveData === true || sensitiveData === false) {\n            return this.options.maskBoolean;\n        }\n\n        if (typeof sensitiveData === 'string') {\n            return this.options.maskString;\n        }\n\n        if (typeof sensitiveData === 'number') {\n            return this.options.maskNumber;\n        }\n\n        return true;\n    }\n\n    /**\n     * Do all the job to mask a sensitive data.\n     *\n     * @private\n     * @param {*} sensitiveData\n     * @returns {string|*}\n     */\n    _doMask(sensitiveData) {\n        if (this._shouldBeMasked(sensitiveData) === false) {\n            return sensitiveData;\n        }\n\n        const data = typeof sensitiveData === 'string' ? sensitiveData : String(sensitiveData);\n        let maskLength = data.length;\n\n        if (data.length > this.options.maxMaskedChars) {\n            maskLength = parseInt(this.options.maxMaskedChars, 10);\n        }\n\n        const maskingCharacters = maskLength - this.options.unmaskedStartChars - this.options.unmaskedEndChars;\n\n        if (maskingCharacters < 0) {\n            if (maskLength <= this.options.unmaskedStartChars) {\n                return data.substr(0, maskLength);\n            }\n\n            let maskedData = data.substr(0, this.options.unmaskedStartChars);\n            const remainingChars = maskLength - this.options.unmaskedStartChars;\n\n            for (let i = data.length - remainingChars; i < data.length; i += 1) {\n                maskedData += data[i];\n            }\n\n            return maskedData;\n        }\n\n        let maskedData = data.substr(0, this.options.unmaskedStartChars);\n\n        maskedData += `${this.options.maskWith}`.repeat(maskingCharacters);\n\n        for (let i = data.length - this.options.unmaskedEndChars; i < data.length; i += 1) {\n            maskedData += data[i];\n        }\n\n        return maskedData;\n    }\n\n    /**\n     * Masks sensitive data.\n     *\n     * Recursive method that support different types of Sensitive Data.\n     * You can provide strings, numbers, booleans, arrays, objects.\n     *\n     * @public\n     * @param {*} sensitiveData\n     * @param {Array} whiteListFields The fields that won't be masked at all. Used if sensitiveData is an object.\n     * @param {Array} blackListFields The fields won't be appeared in a result. Used if sensitiveData is an object\n     * @returns {*}\n     */\n    mask(sensitiveData, whiteListFields = [], blackListFields = []) {\n        if (Array.isArray(sensitiveData)) {\n            return sensitiveData.map((item) => this.mask(item, whiteListFields, blackListFields));\n        }\n\n        if (sensitiveData === undefined || sensitiveData === null) {\n            return this._doMask(sensitiveData);\n        }\n\n        if (typeof sensitiveData === 'object') {\n            const maskedData = {};\n\n            Object.keys(sensitiveData)\n                .filter((key) => !blackListFields.includes(key))\n                .forEach((key) => {\n                    maskedData[key] = whiteListFields.includes(key)\n                        ? sensitiveData[key]\n                        : this.mask(sensitiveData[key], whiteListFields, blackListFields);\n                });\n\n            return maskedData;\n        }\n\n        return this._doMask(sensitiveData);\n    }\n}\n"],"file":"mask-data.js"}